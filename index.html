<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>3D Cloth Simulation â€“ Simplified Drag Fix</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.5.0/lib/p5.min.js"></script>
    <style>
      body, html {
        margin: 0;
        padding: 0;
        background: #111;
        color: #fff;
        font-family: Arial, sans-serif;
        height: 100%;
      }
      #uiPanel {
        position: absolute;
        top: 0;
        left: 0;
        width: 280px;
        height: 100%;
        background: #222;
        box-shadow: 2px 0 8px rgba(0,0,0,0.5);
        padding: 20px;
        box-sizing: border-box;
        overflow-y: auto;
      }
      #canvasContainer {
        position: absolute;
        top: 0;
        left: 280px;
        width: calc(100% - 280px);
        height: 100%;
        overflow: hidden;
      }
      /* Other styles as before... */
    </style>
  </head>
  <body>
    <!-- UI Panel with simplified controls -->
    <div id="uiPanel">
      <h2>3D Cloth Simulation</h2>
      <div class="bottomButtons">
        <button id="playPauseBtn">Pause Simulation</button>
        <button id="resetOrientationBtn">Reset Orientation</button>
        <button id="resetBtn">Reset Cloth</button>
        <button id="toggleDragBtn">Toggle Drag Mode</button>
      </div>
    </div>

    <div id="canvasContainer"></div>

    <script>
      /* CLOTH SETTINGS */
      let cols = 20, rows = 20, spacing = 20;
      let clothPoints = [], clothConstraints = [];
      let grid = [];

      /* SPHERE for draping */
      let sphereCentre = { x: 0, y: 0, z: 0 };
      let sphereRadius = 100;

      /* Simulation parameters */
      let gravity = 0.4;
      let damping = 0.98;

      /* MODES */
      let interactionMode = "drag";  // "rotate" or "drag"
      let simulationMode = "plane";

      /* FLAGS */
      let doResetOrientation = false;
      let simulationRunning = true;

      /* DRAGGING VARIABLES */
      let dragPointIndex = null;
      let selectionRadius = 50; // Increased for easier selection

      function setup() {
        let cnv = createCanvas(windowWidth - 280, windowHeight, WEBGL);
        cnv.parent("canvasContainer");
        createUI();
        setupCloth();
      }

      function createUI() {
        select("#resetBtn").mousePressed(setupCloth);
        select("#resetOrientationBtn").mousePressed(() => { 
          doResetOrientation = true;
        });

        select("#playPauseBtn").mousePressed(() => {
          simulationRunning = !simulationRunning;
          select("#playPauseBtn").html(simulationRunning ? "Pause Simulation" : "Play Simulation");
        });
        
        select("#toggleDragBtn").mousePressed(() => {
          interactionMode = (interactionMode === "rotate") ? "drag" : "rotate";
          select("#toggleDragBtn").html(interactionMode === "drag" ? "Switch to Rotate" : "Switch to Drag");
        });
      }

      function setupCloth() {
        clothPoints = [];
        clothConstraints = [];
        grid = [];
        dragPointIndex = null;

        let clothWidth = (cols - 1) * spacing;
        let clothHeight = (rows - 1) * spacing;
        let startX = -clothWidth/2;
        let startY = -clothHeight/2;

        // Create cloth points
        for (let y = 0; y < rows; y++) {
          grid[y] = [];
          for (let x = 0; x < cols; x++) {
            let px = startX + x * spacing;
            let py = startY + y * spacing;
            let pz = 0;
            
            // Pin the top row
            let pinned = (y === 0);
            
            clothPoints.push({
              x: px, y: py, z: pz,
              oldx: px, oldy: py, oldz: pz,
              pinned: pinned,
              userDragged: false
            });
            grid[y][x] = clothPoints.length - 1;
          }
        }

        // Create constraints
        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            let idx = grid[y][x];
            // Horizontal constraints
            if (x < cols - 1) {
              addConstraint(idx, grid[y][x+1], spacing);
            }
            // Vertical constraints
            if (y < rows - 1) {
              addConstraint(idx, grid[y+1][x], spacing);
            }
          }
        }
      }

      function addConstraint(i, j, len) {
        clothConstraints.push({ p1: i, p2: j, length: len });
      }

      function updateCloth() {
        // Update positions based on velocity
        for (let i = 0; i < clothPoints.length; i++) {
          let p = clothPoints[i];
          if (!p.pinned && !p.userDragged) {
            // Apply velocity with damping
            let vx = (p.x - p.oldx) * damping;
            let vy = (p.y - p.oldy) * damping;
            let vz = (p.z - p.oldz) * damping;
            
            // Save old position
            p.oldx = p.x;
            p.oldy = p.y;
            p.oldz = p.z;
            
            // Apply gravity and velocity
            p.x += vx;
            p.y += vy + gravity;
            p.z += vz;
          }
        }

        // Apply constraints
        for (let i = 0; i < 5; i++) { // Multiple iterations for stability
          for (let c of clothConstraints) {
            let p1 = clothPoints[c.p1];
            let p2 = clothPoints[c.p2];
            
            // Skip constraints if either point is being dragged
            if (p1.userDragged || p2.userDragged) continue;
            
            // Calculate distance between points
            let dx = p2.x - p1.x;
            let dy = p2.y - p1.y;
            let dz = p2.z - p1.z;
            let distance = sqrt(dx*dx + dy*dy + dz*dz);
            
            // Calculate displacement needed
            let diff = (distance - c.length) / distance;
            
            // Apply half of the correction to each point
            let offsetX = dx * 0.5 * diff;
            let offsetY = dy * 0.5 * diff;
            let offsetZ = dz * 0.5 * diff;
            
            if (!p1.pinned && !p1.userDragged) {
              p1.x += offsetX;
              p1.y += offsetY;
              p1.z += offsetZ;
            }
            
            if (!p2.pinned && !p2.userDragged) {
              p2.x -= offsetX;
              p2.y -= offsetY;
              p2.z -= offsetZ;
            }
          }
        }
      }

      // SIMPLIFIED DRAG FUNCTIONALITY
      function mousePressed() {
        if (interactionMode === "drag") {
          // Find closest point in screen space
          let closestPoint = null;
          let closestDist = selectionRadius;
          
          for (let i = 0; i < clothPoints.length; i++) {
            let p = clothPoints[i];
            if (p.pinned) continue; // Skip pinned points
            
            // Convert 3D to screen space - use the global p5.js functions directly
            let sx = screenX(p.x, p.y, p.z);
            let sy = screenY(p.x, p.y, p.z);
            
            // Check distance to mouse position
            let d = dist(mouseX, mouseY, sx, sy);
            if (d < closestDist) {
              closestDist = d;
              closestPoint = i;
            }
          }
          
          if (closestPoint !== null) {
            dragPointIndex = closestPoint;
            clothPoints[dragPointIndex].userDragged = true;
          }
        }
      }

      function mouseDragged() {
        if (interactionMode === "drag" && dragPointIndex !== null) {
          let p = clothPoints[dragPointIndex];
          
          // Create a simplified mapping from mouse to world coordinates
          let mouseVector = createVector(
            (mouseX - width/2),  
            (mouseY - height/2),
            -200 // Fixed depth
          );
          
          // Scale the vector to make dragging feel right
          let scaleFactor = 1.0;
          
          // Update point position
          p.x = mouseVector.x * scaleFactor;
          p.y = mouseVector.y * scaleFactor;
          
          // Prevent velocity by setting old position to current
          p.oldx = p.x;
          p.oldy = p.y;
        }
      }

      function mouseReleased() {
        if (dragPointIndex !== null) {
          clothPoints[dragPointIndex].userDragged = false;
          dragPointIndex = null;
        }
      }

      function draw() {
        background(30);

        if (doResetOrientation) {
          camera(0, 0, 500, 0, 0, 0, 0, 1, 0);
          doResetOrientation = false;
        }

        if (interactionMode === "rotate") {
          orbitControl();
        }

        if (simulationRunning) {
          updateCloth();
        }

        // Draw cloth
        stroke(255);
        strokeWeight(1);
        noFill();
        
        // Draw constraints (lines)
        for (let c of clothConstraints) {
          let p1 = clothPoints[c.p1];
          let p2 = clothPoints[c.p2];
          line(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
        }
        
        // Draw points
        noStroke();
        for (let i = 0; i < clothPoints.length; i++) {
          let p = clothPoints[i];
          push();
          translate(p.x, p.y, p.z);
          
          if (p.userDragged) {
            // Dragged point
            fill(255, 0, 0);
            sphere(8);
          } else if (p.pinned) {
            // Pinned point
            fill(0, 255, 0);
            sphere(4);
          } else {
            // Regular point
            fill(255);
            sphere(2);
          }
          pop();
        }
      }

      function windowResized() {
        resizeCanvas(windowWidth - 280, windowHeight);
      }
    </script>
  </body>
</html>
