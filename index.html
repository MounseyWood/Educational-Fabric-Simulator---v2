<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>3D Cloth Simulation â€“ Minimal Version</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.5.0/lib/p5.min.js"></script>
    <style>
      body, html {
        margin: 0;
        padding: 0;
        background: #111;
        color: #fff;
        font-family: Arial, sans-serif;
        height: 100%;
      }
      button {
        padding: 8px 12px;
        background: #555;
        color: #fff;
        border: none;
        cursor: pointer;
        margin: 5px;
      }
      button:hover { background: #666; }
      #controls {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 100;
      }
    </style>
  </head>
  <body>
    <div id="controls">
      <button id="pauseBtn">Pause Simulation</button>
      <button id="resetBtn">Reset Cloth</button>
      <button id="resetOrientationBtn">Reset Orientation</button>
      <button id="toggleDragBtn">Switch to Rotate</button>
    </div>

    <script>
      let cols = 20, rows = 20, spacing = 20;
      let clothPoints = [];
      let clothConstraints = [];
      let grid = [];

      // Simulation parameters
      let gravity = 0.4;
      let damping = 0.98;

      // Flags and modes
      let interactionMode = "drag";
      let simulationRunning = true;
      let doResetOrientation = false;
      let dragPointIndex = null;

      // Camera settings
      let cameraDistance = 500;
      
      function setup() {
        createCanvas(windowWidth, windowHeight, WEBGL);
        
        // UI controls
        select('#pauseBtn').mousePressed(() => {
          simulationRunning = !simulationRunning;
          select('#pauseBtn').html(simulationRunning ? 'Pause Simulation' : 'Play Simulation');
        });
        
        select('#resetBtn').mousePressed(setupCloth);
        
        select('#resetOrientationBtn').mousePressed(() => {
          doResetOrientation = true;
        });
        
        select('#toggleDragBtn').mousePressed(() => {
          interactionMode = (interactionMode === 'drag') ? 'rotate' : 'drag';
          select('#toggleDragBtn').html(interactionMode === 'drag' ? 'Switch to Rotate' : 'Switch to Drag');
        });
        
        setupCloth();
      }

      function setupCloth() {
        clothPoints = [];
        clothConstraints = [];
        grid = [];
        dragPointIndex = null;

        let clothWidth = (cols - 1) * spacing;
        let clothHeight = (rows - 1) * spacing;
        let startX = -clothWidth/2;
        let startY = -clothHeight/2;

        // Create points
        for (let y = 0; y < rows; y++) {
          grid[y] = [];
          for (let x = 0; x < cols; x++) {
            let px = startX + x * spacing;
            let py = startY + y * spacing;
            let pz = 0;
            let pinned = (y === 0); // Pin top row
            
            clothPoints.push({
              x: px, y: py, z: pz,
              oldx: px, oldy: py, oldz: pz,
              pinned: pinned,
              userDragged: false
            });
            
            grid[y][x] = clothPoints.length - 1;
          }
        }

        // Create constraints
        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            let idx = grid[y][x];
            // Horizontal constraints
            if (x < cols - 1) {
              clothConstraints.push({
                p1: idx,
                p2: grid[y][x+1],
                length: spacing
              });
            }
            // Vertical constraints
            if (y < rows - 1) {
              clothConstraints.push({
                p1: idx,
                p2: grid[y+1][x],
                length: spacing
              });
            }
          }
        }
      }

      function updateCloth() {
        // Apply physics
        for (let i = 0; i < clothPoints.length; i++) {
          let p = clothPoints[i];
          if (!p.pinned && !p.userDragged) {
            // Apply velocity with damping
            let vx = (p.x - p.oldx) * damping;
            let vy = (p.y - p.oldy) * damping;
            let vz = (p.z - p.oldz) * damping;
            
            // Save old position
            p.oldx = p.x;
            p.oldy = p.y;
            p.oldz = p.z;
            
            // Apply forces
            p.x += vx;
            p.y += vy + gravity;
            p.z += vz;
          }
        }

        // Apply constraints multiple times for stability
        for (let iter = 0; iter < 5; iter++) {
          for (let c of clothConstraints) {
            let p1 = clothPoints[c.p1];
            let p2 = clothPoints[c.p2];
            
            // Skip if dragged
            if (p1.userDragged || p2.userDragged) continue;
            
            // Calculate distance and direction
            let dx = p2.x - p1.x;
            let dy = p2.y - p1.y;
            let dz = p2.z - p1.z;
            let distance = sqrt(dx*dx + dy*dy + dz*dz);
            
            // Calculate correction
            let diff = (distance - c.length) / distance;
            
            // Apply half correction to each point
            let correctionX = dx * 0.5 * diff;
            let correctionY = dy * 0.5 * diff;
            let correctionZ = dz * 0.5 * diff;
            
            if (!p1.pinned && !p1.userDragged) {
              p1.x += correctionX;
              p1.y += correctionY;
              p1.z += correctionZ;
            }
            
            if (!p2.pinned && !p2.userDragged) {
              p2.x -= correctionX;
              p2.y -= correctionY;
              p2.z -= correctionZ;
            }
          }
        }
      }

      // SIMPLIFIED DIRECT DRAG APPROACH
      function mousePressed() {
        if (interactionMode === "drag") {
          // Convert mouse coordinates to ray direction
          let rayDir = createVector(
            (mouseX - width/2) / (width/2),
            (mouseY - height/2) / (height/2) * -1,
            -1
          ).normalize();
          
          // Find best point to drag
          let bestPoint = null;
          let bestScore = -Infinity;
          
          for (let i = 0; i < clothPoints.length; i++) {
            let p = clothPoints[i];
            if (p.pinned) continue;
            
            // Simple distance-based scoring (no screen space conversion)
            let pointVec = createVector(p.x, p.y, p.z);
            
            // Score based on alignment with ray and distance
            let alignmentScore = pointVec.dot(rayDir);
            let distScore = -pointVec.mag(); // Prefer closer points
            
            let score = alignmentScore + distScore * 0.1;
            
            if (score > bestScore) {
              bestScore = score;
              bestPoint = i;
            }
          }
          
          if (bestPoint !== null) {
            dragPointIndex = bestPoint;
            clothPoints[dragPointIndex].userDragged = true;
          }
        }
      }

      function mouseDragged() {
        if (interactionMode === "drag" && dragPointIndex !== null) {
          let p = clothPoints[dragPointIndex];
          
          // Direct mapping of mouse to 3D space
          // Scale factor adjusts sensitivity
          let scaleFactor = 1.5;
          
          p.x = (mouseX - width/2) * scaleFactor;
          p.y = (mouseY - height/2) * scaleFactor;
          
          // Keep old position updated to prevent velocity
          p.oldx = p.x;
          p.oldy = p.y;
        }
      }

      function mouseReleased() {
        if (dragPointIndex !== null) {
          clothPoints[dragPointIndex].userDragged = false;
          dragPointIndex = null;
        }
      }

      function draw() {
        background(30);
        
        // Camera control
        if (doResetOrientation) {
          perspective(PI/3, width/height, 0.1, 1000);
          camera(0, 0, cameraDistance, 0, 0, 0, 0, 1, 0);
          doResetOrientation = false;
        }
        
        if (interactionMode === "rotate") {
          orbitControl();
        }
        
        if (simulationRunning) {
          updateCloth();
        }
        
        // Draw the cloth
        stroke(255);
        strokeWeight(1);
        noFill();
        
        // Draw constraints
        for (let c of clothConstraints) {
          let p1 = clothPoints[c.p1];
          let p2 = clothPoints[c.p2];
          line(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);
        }
        
        // Draw points
        noStroke();
        for (let i = 0; i < clothPoints.length; i++) {
          let p = clothPoints[i];
          push();
          translate(p.x, p.y, p.z);
          
          if (p.userDragged) {
            fill(255, 0, 0);  // Red for dragged points
            sphere(8);
          } else if (p.pinned) {
            fill(0, 255, 0);  // Green for pinned points
            sphere(4);
          } else {
            fill(255);        // White for regular points
            sphere(2);
          }
          pop();
        }
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
      }
    </script>
  </body>
</html>
